<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  background-image: linear-gradient(to right top, #eeeeee, #e2e2e2, #d5d5d5, #c9c9c9, #bdbdbd);
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 0px;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.axis text {
  font: 10px sans-serif;
}

.cells path {
  fill: none;
  pointer-events: all;
}

.cells :hover circle {
  fill: red;
}
g.gridlines.axis--x path{
  stroke: none;
}

.gridlines line{
  stroke: #90A4AE;
  stroke-width: .8px;
  stroke-opacity: 0.4;
}

g.axis.axis--x path{
  stroke: none;
}

g.axis.axis--x line{
  stroke: none;
  stroke-width: 1px;
}

g.axis.axis--x g text{
  font-size: 10px;
  font-family: 'Inconsolata', monospace;
}

g.axis.axis--x text.label{
  font-size: 12p  x;
  font-family: 'Inconsolata', monospace;
}

</style>
<svg width="800" height="400">
  <defs>
    <filter id="dropshadow" x="-40%" y="-40%" width="180%" height="180%" filterUnits="userSpaceOnUse">
      <feGaussianBlur in="SourceAlpha" stdDeviation="3"/> <!-- stdDeviation is how much to blur -->
      <feOffset dx="5" dy="5" result="offsetblur"/>
      <feOffset dx="-5" dy="-5" result="offsetblur"/>
      <feComponentTransfer>
        <feFuncA type="linear" slope="0.5"/> <!-- slope is the opacity of the shadow -->
      </feComponentTransfer>
      <feMerge>
        <feMergeNode/>
        <feMergeNode in="SourceGraphic"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>

  </defs>
</svg>

<script src="https://d3js.org/d3.v5.min.js"></script>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet">
<script>

// define svg and dimensions of chart
const svg = d3.select("svg"),
    margin = {top: 40, right: 40, bottom: 40, left: 40},
    SVGWidth = svg.attr("width"),
    SVGHeight = svg.attr("height"),
    width = SVGWidth - margin.left - margin.right,
    height = SVGHeight - margin.top - margin.bottom;

// function to get half century units from data
// voronoi (logical) indicates if voronoi function has been applied to data
function getHCUnits(d, voronoi) {
  let centuries = voronoi ? d.data.Centuries : d.Centuries;
  let halfCenturies = voronoi ? d.data.HalfCenturies : d.HalfCenturies;
  return halfCenturies + 2 * (centuries);
}


// defining all relevant scales

// batting average across x
let x = d3.scaleLinear()
    .range([0, width]);
// radius mapped to strike rate
let radScale = d3.scaleSqrt()
                .range([5, 15])
// stroke colored to team and sized proportional to radius
let strokeScale = d3.scaleSqrt()
                .range([1, 4])
// an outline outside circle to denote half centuries
let centuryScale = d3.scaleSqrt()
                .range([0, 4])
// categorical scale for team colors
let colScale = d3.scaleOrdinal()
                  .domain(['Peshawar Zalmi', 'Islamabad United', 'Quetta Gladiators', 'Lahore Qalandars', 'Karachi Kings', 'Multan Sultans'])
                  .range(['#FFEB3B','#EF6C00', '#512DA8','#B71C1C', '#9C27B0', '#43A047']);



async function readAndDrawBeeswarm(){
  let data = await d3.csv('PSL_Batting.csv')
  // add ids and photo links
  preProcssData(data);

  drawBeeswarm(data);
}

readAndDrawBeeswarm();

function drawBeeswarm(data){
    const g = svg.append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    const defs = svg.selectAll("defs")
      .data(data)
      .enter()
      .append("defs")

    defs.append("pattern")
      .attr('id', d => d.id)
      .attr('height', '100%')
      .attr('width', '100%')
      .attr("patternContentUnits", "objectBoundingBox")
      .append("image")
      .attr('height', 1)
      .attr('width', 1)
      .attr('preserveAspectRatio', 'none')
      .attr("xlink:href", d => d.photoLink);

    x.domain(d3.extent(data, function(d) { return +d.Avg; }));
    radScale.domain(d3.extent(data, function(d) { return +d.SR; }));
    strokeScale.domain(d3.extent(data, function(d) { return +d.SR; }));
    centuryScale.domain(d3.extent(data, function(d) { return getHCUnits(d, false); }))

    let simulation = d3.forceSimulation(data)
        .force("x", d3.forceX(function(d) { return x(+d.Avg); }).strength(5))
        .force("y", d3.forceY(height / 2))
        .force("collision", d3.forceCollide().radius(d => radScale(d.SR) + strokeScale(d.SR) /*+ centuryScale(getHCUnits(d, false))*/))
        .stop();

    // complete force simulation to get to equilibrium
    for (var i = 0; i < 500; ++i) simulation.tick();

    g.append("g")
        .attr("class", "axis axis--x")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x).tickValues(d3.range(0, 50, 5)))

    g.select(".axis.axis--x")
      .append('text')
      .attr('class', 'label axis --x')
      .text('Batting Average')
      .style('text-anchor', 'start')
      .style('fill', 'black')
      .attr('transform', 'translate(0, 12)');



    const xGridlines = d3.axisBottom()
                        .scale(x)
                        .tickSize(height)
                        .tickFormat("")

    g.append("g")
      .attr("class", "gridlines axis--x")
      .call(xGridlines);

    d3.selectAll('g.axis.axis--x g text')
      .attr('transform', 'translate(10, -18)')


    data = data.filter(d => !isNaN(d.Avg))


    let voronoi = d3.voronoi()
                    .extent([[-margin.left,  -margin.top], [width + margin.right, height + margin.top]])
                    .x(function(d) { return d.x; })
                    .y(function(d) { return d.y; })

    let cell = g.append("g")
        .attr("class", "cells")
        .selectAll("g")
        .data(voronoi.polygons(data))
        .enter()
        .append("g");

    cell.append("circle")
        .attr('class', 'centuries')
        .attr("r", d => radScale(d.data.SR) + (strokeScale(d.data.SR)/2) + centuryScale(getHCUnits(d, true)))
        .attr("cx", function(d) { return d.data.x; })
        .attr("cy", function(d) { return d.data.y; })
        //.style('fill', d => colScale(d.data.Team))
        .style("fill", 'grey')
        .style('filter', 'url(#dropshadow)')
        .style("fill-opacity", 0.2)
        .style('stroke', 'black')
        .style("stroke-width", d => {
          if (d.data.Centuries > 0 || d.data.HalfCenturies > 0){
            return .5
          }
          else {
            return 0
          }
        })
        .style('stroke-opacity', 0.6)

    cell.append("circle")
        .attr('class', 'team-strikeRate')
        .attr("r", d => radScale(d.data.SR))
        .attr("cx", function(d) { return d.data.x; })
        .attr("cy", function(d) { return d.data.y; })
        //.style('fill', d => colScale(d.data.Team))
        .style("fill", d => `url(#${d.data.id})`)
        .style('stroke', d => colScale(d.data.Team))
        .style("stroke-width", d => strokeScale(d.data.SR) + "px")


    cell.append("path")
        .attr("d", function(d) { return "M" + d.join("L") + "Z"; });

    cell.append("title")
        .text(function(d) { console.log(d.data) }); //return d.data.Name + "\n" + d.data.Avg + "\n" + d.data.SR;
}

function preProcssData(data){
  data.forEach(d => {
    d.photoLink = `photos/${d.Name}.jpg`
    d.id = d.Name.replace(/ /g, "");
  })
}

</script>
